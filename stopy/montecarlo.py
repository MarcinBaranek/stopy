import numpy as np
from collections.abc import Iterable
from concurrent.futures import ThreadPoolExecutor
import scipy.stats as st
import traceback


class MonteCarlo:
    """Monte Carlo basic class for carrying out monte carlo simulations.
    A class is not useful for practical tasks,
    it exists because it is the foundation for subsequent classes
    """
    def __init__(self, func=None):
        """Constructor, only assigns the functions to be 'averaged'
        :param func: functions, Identity is assigned by default
        """
        self.func = func if func is not None else lambda x: x

    @staticmethod
    def iter_arg(n_yield=1, *args, **kwargs):
        """Function that returns a generator of arguments that
        can be passed to the function
        # ToDo move this from here
        :param n_yield: int, the number of times the arguments are to be
         returned, if it is less than 0, returns any number of arguments
        :param args: arguments
        :param kwargs: dictionary
        :return: generator, returning args and kwargs
        """
        if n_yield < 0:
            while True:
                yield args, kwargs
        else:
            for _ in range(n_yield):
                yield args, kwargs

    @staticmethod
    def iter_gen(n_yield=1, gen=np.random.rand, *args, **kwargs):
        """Function returns the generator returning the successive elements
        generated by the generator function
        # ToDo move this from here
        :param n_yield: int, the number of times the elements are to be
        returned, if it is less than 0, returns any number of elements
        :param gen: function, generator function, default function generating
         pseudorandom numbers from uniform distribution on [0,1)
        :param args: arguments passed to the generator function
        :param kwargs: dictionaries passed to the generator function
        :return: generator, returning subsequent evaluations of the generated
         function with args and kwargs, gen(arg, kwargs)
        """
        if n_yield < 0:
            while True:
                yield gen(args, kwargs)
        else:
            for _ in range(n_yield):
                yield gen(args, kwargs)

    @staticmethod
    def fast_mean(func, param, n_sim=10, workers=3):
        """
        # ToDO write the documentation
        :param func:
        :param param:
        :param n_sim:
        :param workers:
        :return:
        """
        param = param if isinstance(param, Iterable) else\
            MonteCarlo.iter_arg(n_sim, param)
        with ThreadPoolExecutor(max_workers=workers) as executor:
            results = executor.map(func, param)
        return np.array([result for result in results]).mean()

    @staticmethod
    def fast_mean_with_variance(func, sample, workers=3):
        """
        # ToDO write the documentation
        :param func:
        :param sample:
        :param workers:
        :return:
        """
        with ThreadPoolExecutor(max_workers=workers) as executor:
            avg = np.array(executor.map(func, sample))
            var = np.array(executor.map(
                lambda x: (func(x) - avg)**2), sample).sum() / (len(sample) - 1)
            return avg, var


class IntegrateMonteCarlo(MonteCarlo):
    def __init__(self, func=None, gen=None):
        """
        # ToDO write the documentation
        :param func:
        :param gen:
        """
        super().__init__(func)
        self.gen = gen if gen is not None else np.random.rand
        self.mean = None
        self.var = None
        self.n_samples = None

    def simulate(self, size=10, var=False, workers=3):
        """
        # ToDO write the documentation
        :param size:
        :param var:
        :param workers:
        :return:
        """
        if var:
            sample = np.array([self.gen() for _ in range(size)])
            self.mean, self.var =\
                self.fast_mean_with_variance(self.func, sample, workers=workers)
            self.n_samples = size
        else:
            self.mean = self.fast_mean(self.func, self.iter_gen(size, self.gen),
                                       workers=workers)

    def confidence_interval(self, alpha=0.05):
        """
        # ToDO write the documentation
        :param alpha:
        :return:
        """
        try:
            margin = st.norm.interval(1.0 - alpha) *\
                      np.sqrt(self.var / self.n_samples)
            return self.mean - margin, self.mean + margin
        except AttributeError as e:
            print(e)
            traceback.print_exc()
            print("make sure you run simulations and calculate variance")
